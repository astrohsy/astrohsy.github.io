<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.2.1">Jekyll</generator><link href="http://astrohsy.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://astrohsy.com/" rel="alternate" type="text/html" /><updated>2016-09-25T22:32:33+09:00</updated><id>http://astrohsy.com/</id><title>ShootingBugs</title><subtitle>참가한 대회와 알고리즘과 머신러닝에 대한 내용들을 올릴 생각입니다.</subtitle><author><name>   Hoseung</name><email>astrohsy@gmail.com</email></author><entry><title>3D프린터를 처음으로 사용해보다.</title><link href="http://astrohsy.com/daily/3D-printer/" rel="alternate" type="text/html" title="3D프린터를 처음으로 사용해보다." /><published>2016-09-25T20:00:00+09:00</published><updated>2016-09-25T20:00:00+09:00</updated><id>http://astrohsy.com/daily/3D-printer</id><content type="html" xml:base="http://astrohsy.com/daily/3D-printer/">&lt;p&gt;학교에서 간단한 프로젝트를 하던 중에 자체적으로 제작해야하는 툴이 생겨서 3D 프린팅에 대해서 알아보기 시작했다. 운좋게도 학교안에 글로벌플라자에 3D 프린터를 무료로 사용할 수 있다는 것을 교수님을 통해 알게 되어서 방문하였다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://farm9.staticflickr.com/8284/29283932984_802897b57e_b.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://c8.staticflickr.com/6/5289/29830840031_e101770979_b.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;근데 3D 프린터를 이용할려면 3D 설계를 한 다음에 &lt;code class=&quot;highlighter-rouge&quot;&gt;.stl&lt;/code&gt; 파일로 제출해야 한다고 했다. 3D 설계는 일반 &lt;code class=&quot;highlighter-rouge&quot;&gt;CAD&lt;/code&gt;나 다른 것들을 사용해도 되지만, &lt;code class=&quot;highlighter-rouge&quot;&gt;123D Design&lt;/code&gt;이 가장 이용하기 쉽다는 조언을 들어서 &lt;code class=&quot;highlighter-rouge&quot;&gt;123D Design&lt;/code&gt;을 사용했다.
우리 프로젝트에서는 DSLR에 3D Depth Sensor를 일체화 시키는 장치를 제작했어야 했는데.
한 팀원이 모델을 완성도 높게 금방 만들어 주었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://farm9.staticflickr.com/8320/29876173306_8da4e76a43_b.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그리고 첫 번째로 출력을 하러 갔다. 출력하는 데 보통 몇 시간 정도 걸리니 내일 다시 오라고 하셨다. 그리고 다음 날, 결과물을 확인하였다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://farm9.staticflickr.com/8189/29911424495_729b4c8546_b.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;처음 뽑아서 몰랐었는데, 3D 프린팅은 한 층 한 층 쌓는 방식이라 설계와는 다르게 비어있어야하는 곳이 약간 채워져 있었다. 이것을 제거해야 했다. 하지만 제거하고도 실제로 장착했을 때, 문제가 있어서 여러번 다시 뽑았다..&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://farm6.staticflickr.com/5279/29283946254_605bb1718e_b.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그래서 이렇게 칼로 다듬기도 하고.. 많은 고생을 했다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;최종결과물&lt;/h2&gt;

&lt;p&gt;마지막에는 치수가 맞는 것을 한번에 찾기 위해서 1mm씩 조절하면서 5개의 모델을 출력했다. 그러니까 이렇게 한 개의 3D프린터에서 같이 붙여져서 나왔다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://farm9.staticflickr.com/8347/29283932474_a728913d7d_z.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그리고 이 모델을 다듬고 본래 원했던 DSLR의 Hot Shoe부분에 장착해본 결과 딱 맞았다! 이제 본격적으로 프로젝트를 시작하면 될 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://farm6.staticflickr.com/5586/29283930484_54f042f6b4_b.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;소감&lt;/h2&gt;

&lt;p&gt;재질은 여러 종류가 있었고, 우리 프로젝트에는 플라스틱 형태의 제류가 적절해 보여서 플라스틱 같은 재질을 사용하였다. 색은 따로 선택할 수 없었다. 하지만 마지막에 DSLR 색과 똑같은 검은색으로 출력되서 운이 좋았다.&lt;/p&gt;

&lt;p&gt;마지막으로 직원분들도 모두 친절하시고, 생각했던 것보다 3D 프린터로 출력된 제품의 완성도가 높아서 좋았다. 뭔가를 손수 제작을 해야하면 3D 프린터를 사용하는 것이 좋은 선택이 될 것 같다. 간단한 물건은 비교적 손쉽게 제작할 수 있고, 인터넷에 3D 설계된 3D 파일이 이미 많이 존재해서 이미 만들어진 것을 출력해도 좋을 것 같다.&lt;/p&gt;</content><author><name>   Hoseung</name><email>astrohsy@gmail.com</email></author><category term="3d-printer" /><summary>학교에서 간단한 프로젝트를 하던 중에 자체적으로 제작해야하는 툴이 생겨서 3D 프린팅에 대해서 알아보기 시작했다. 운좋게도 학교안에 글로벌플라자에 3D 프린터를 무료로 사용할 수 있다는 것을 교수님을 통해 알게 되어서 방문하였다.</summary></entry><entry><title>CUDA로 배워보는 병렬 프로그래밍(Parallel Programming) - 데이터이동</title><link href="http://astrohsy.com/parallel/parallel-programing-calculate-1/" rel="alternate" type="text/html" title="CUDA로 배워보는 병렬 프로그래밍(Parallel Programming) - 데이터이동" /><published>2016-09-24T22:00:00+09:00</published><updated>2016-09-24T22:00:00+09:00</updated><id>http://astrohsy.com/parallel/parallel-programing-calculate-1</id><content type="html" xml:base="http://astrohsy.com/parallel/parallel-programing-calculate-1/">&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CUDA&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;C++ like Language&lt;/code&gt;이다. 사실상, C++에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;CUDA&lt;/code&gt; 관련 라이브러리가 추가되어 있는 구조라고 생각하면 쉽다. 그래서 &lt;code class=&quot;highlighter-rouge&quot;&gt;CUDA&lt;/code&gt; 파일인 &lt;code class=&quot;highlighter-rouge&quot;&gt;.cu&lt;/code&gt; 소스파일을 실행시키면 다음 사진과 같이 실행을 시킨다.
&lt;img src=&quot;https://c4.staticflickr.com/9/8230/29267752363_60e1c95eca_b.jpg&quot; alt=&quot;logic&quot; /&gt;
그리고 CPU가 실행시키는 코드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;serial 코드(host)&lt;/code&gt;라고 부르고, GPU가 실행시키는 코드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Kernel 코드(device)&lt;/code&gt;라고 부른다. CPU가 실행히키는 코드는 순차적으로 실행시키고 &lt;code class=&quot;highlighter-rouge&quot;&gt;CUDA&lt;/code&gt; 코드를 실행시키면 그때부터 병렬로 실행되고, CPU는 병렬 코드가 끝날 때까지 기다리는 구조이다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;데이터 전송&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CUDA&lt;/code&gt; 및 다른 병렬 프로그래밍을 할 때는 &lt;code class=&quot;highlighter-rouge&quot;&gt;GPU&lt;/code&gt;를 사용를 하여야 한다. 하지만, 이 &lt;code class=&quot;highlighter-rouge&quot;&gt;GPU&lt;/code&gt;를 사용하기 위해선 &lt;code class=&quot;highlighter-rouge&quot;&gt;GPU&lt;/code&gt; 안에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;VRAM&lt;/code&gt;으로 처리할 데이터를 옮겨나야 한다. 그렇기 때문에 병렬 프로그래밍을 공부할 때 가장 먼저 배워야하는 것이 &lt;code class=&quot;highlighter-rouge&quot;&gt;DRAM -&amp;gt; VRAM&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;VRAM -&amp;gt; DRAM&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;VRAM -&amp;gt; VRAM&lt;/code&gt;과 같이 데이터를 옮기는 것이다.&lt;/p&gt;

&lt;p&gt;데이터 전송을 하기 전에 &lt;code class=&quot;highlighter-rouge&quot;&gt;CUDA&lt;/code&gt;에서는 몇 가지 규칙이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 &lt;code class=&quot;highlighter-rouge&quot;&gt;CUDA&lt;/code&gt; library 함수들은 &lt;code class=&quot;highlighter-rouge&quot;&gt;cuda&lt;/code&gt;로 시작하다.&lt;/li&gt;
  &lt;li&gt;Library 함수들은 error code 혹은 &lt;code class=&quot;highlighter-rouge&quot;&gt;cudaSucess&lt;/code&gt;를 반환한다.&lt;/li&gt;
  &lt;li&gt;GPU에서 사용할 변수들은 앞에 &lt;code class=&quot;highlighter-rouge&quot;&gt;dev_&lt;/code&gt;를 붙여야한다.&lt;/li&gt;
  &lt;li&gt;host 함수 앞에는 __host__을 붙인다.&lt;/li&gt;
  &lt;li&gt;device 함수 앞에는 __device__ 혹은 __global__을 붙여야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러면 간단하게 배열을 &lt;code class=&quot;highlighter-rouge&quot;&gt;GPU&lt;/code&gt;를 거쳐서 카피하는 코드를 작성해보면 다음과 같다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;cstdio&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//host 데이터
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{ %d, %d }&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// device 데이터
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev_a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev_b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// VRAM에 메모리 할당 (c언어의 malloc과 동일 역활)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;cudaMalloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cudaMalloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// host -&amp;gt; device로 카피
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;cudaMemcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cudaMemcpyHostToDevice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// device -&amp;gt; device 카피
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;cudaMemcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dev_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cudaMemcpyDeviceToDevice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// device -&amp;gt; host 카피
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;cudaMemcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dev_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cudaMemcpyDeviceToHost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 메모리 할당 해제
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;cudaFree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cudaFree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{ %d, %d }&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cudaMalloc&lt;/code&gt;은 메모리 할당을 위해 쓰고, 첫번째 파라미터로는 할당할 포인터, 두 번째 파라미터로는 할당할 사이즈가 들어간다. 성공시에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;cudaSuccess&lt;/code&gt; 실패시에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;cudaErrorMemoryAllocation&lt;/code&gt;을 반환한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cudaMemcpy&lt;/code&gt;는 메모리를 복사를 할 때 사용을 하고, 첫 번째 파라미터는 목적지 주소의 포인터, 두 번째 파라미터는 복사할 주소의 포인터, 세 번째는 복사할 크기, 마지막은 &lt;code class=&quot;highlighter-rouge&quot;&gt;cudaMemcpyKind&lt;/code&gt;인데 이것은 (&lt;code class=&quot;highlighter-rouge&quot;&gt;cudaMemcpyHostToHost&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;cudaMemcpyHostToDevice&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;cudaMemcpyDeviceToDevice&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;cudaMemcpyDeviceToHost&lt;/code&gt;) 이다.
그리고 &lt;code class=&quot;highlighter-rouge&quot;&gt;cudaMemcpy&lt;/code&gt;는 카피가 끝날 때까지 CPU 쓰레드를 블록시킨다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cudaFree&lt;/code&gt;는 free와 동일하게 메모리를 해제시킨다.&lt;/p&gt;</content><author><name>   Hoseung</name><email>astrohsy@gmail.com</email></author><category term="parallel" /><category term="cuda" /><summary>CUDA는 C++ like Language이다. 사실상, C++에서 CUDA 관련 라이브러리가 추가되어 있는 구조라고 생각하면 쉽다. 그래서 CUDA 파일인 .cu 소스파일을 실행시키면 다음 사진과 같이 실행을 시킨다.

그리고 CPU가 실행시키는 코드는 serial 코드(host)라고 부르고, GPU가 실행시키는 코드는 Kernel 코드(device)라고 부른다. CPU가 실행히키는 코드는 순차적으로 실행시키고 CUDA 코드를 실행시키면 그때부터 병렬로 실행되고, CPU는 병렬 코드가 끝날 때까지 기다리는 구조이다.</summary></entry><entry><title>동적계획법(Dynamic Programming) - 입문</title><link href="http://astrohsy.com/algorithm/dynamic-programming-2/" rel="alternate" type="text/html" title="동적계획법(Dynamic Programming) - 입문" /><published>2016-09-22T00:00:00+09:00</published><updated>2016-09-22T00:00:00+09:00</updated><id>http://astrohsy.com/algorithm/dynamic-programming-2</id><content type="html" xml:base="http://astrohsy.com/algorithm/dynamic-programming-2/">&lt;p&gt;다이나믹 프로그래밍은 문제를 많이 풀어봐야지 느낌이 오는 것 같다. 그래서 이 글에서는 가장 기초적인 다이나믹 프로그램을 활용해야하는 문제에 내가 했던 접근을 설명할 생각이다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;계단오르기&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2579&quot;&gt;2579번 계단오르기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;우선, 이 문제의 설명을 보면 다음과 같은 제약들이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.&lt;/li&gt;
  &lt;li&gt;연속된 세 개의 계단을 모두 밟아서는 안된다. 단, 시작점은 계단에 포함되지 않는다.&lt;/li&gt;
  &lt;li&gt;마지막 도착 계단은 반드시 밟아야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 조건을 모두 만족시키는 경우 중에서도 최대의 값으로 가는 경우의 점수를 구해야한다.&lt;/p&gt;

&lt;p&gt;다이나믹 프로그래밍에선 중요한 것은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이미 계산했던 값은 계산하지 말자.&lt;/li&gt;
  &lt;li&gt;문제의 제약을 이해한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 문제에서 어떨 때, 중복 계산하는 경우가 발생하는지 생각을 해보자.&lt;/p&gt;

&lt;p&gt;생각을 해보면 다음과 같은 경우 항상 같은 값이 계산되는 것을 알 수 있다.
&amp;gt; 지금 N번째 계단에 있는데, 지금까지 K개의 연속된 계단을 밟은 상태이다.&lt;/p&gt;

&lt;p&gt;중복이 발생하는 경우를 찾았으니, 이제 이 경우를 점화식으로 나타내어야한다. 점화식은 &lt;code class=&quot;highlighter-rouge&quot;&gt;D[N][1] = max(D[N-2][1], D[N-2][2]) + (N번째 계단의 점수)&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;D[N][2] = D[N-1][1] + (N번째 계단의 점수)&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;이 식을 반복문을 이용한 동적계획법으로 풀면 다음과 같다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;cstdio&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;301&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;301&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;scanf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;scanf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;section-1&quot;&gt;1로 만들기&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1463&quot;&gt;1463번 1로 만들기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;어떤 숫자 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;가 주어져 있을 때, 1로 만드는 최소의 연산 횟수를 구하는 문제이다.
이 문제 같은 경우의 조건은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;X가 3으로 나누어 떨어지면, 3으로 나눈다.&lt;/li&gt;
  &lt;li&gt;X가 2로 나누어 떨어지면, 2로 나눈다.&lt;/li&gt;
  &lt;li&gt;1을 뺀다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 문제도 한 번 곰곰히 어떻게 접근해야할지 생각해본다.&lt;/p&gt;

&lt;p&gt;이 경우 해당 숫자에 대해서 계속 최소값으로 갱신시키면 된다. 다음과 같이 점화식을 세울수 있다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;X가 3으로 나누어지면 D[X] = min(D[X], D[X-3] + 1)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;X가 2로 나누어지면 D[X] = min(D[X], D[X-2] + 1)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;모든 경우 D[X] = min(D[X], D[X] + 1)&lt;/code&gt;이다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;algorithm&amp;gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;scanf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 초기값
&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2e9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name>   Hoseung</name><email>astrohsy@gmail.com</email></author><category term="dynamic programming" /><summary>다이나믹 프로그래밍은 문제를 많이 풀어봐야지 느낌이 오는 것 같다. 그래서 이 글에서는 가장 기초적인 다이나믹 프로그램을 활용해야하는 문제에 내가 했던 접근을 설명할 생각이다.</summary></entry><entry><title>CUDA로 배워보는 병렬 프로그래밍(Parallel Programming) - 1</title><link href="http://astrohsy.com/parallel/intro-to-parallel-programming/" rel="alternate" type="text/html" title="CUDA로 배워보는 병렬 프로그래밍(Parallel Programming) - 1" /><published>2016-09-21T00:00:00+09:00</published><updated>2016-09-21T00:00:00+09:00</updated><id>http://astrohsy.com/parallel/intro-to-parallel-programming</id><content type="html" xml:base="http://astrohsy.com/parallel/intro-to-parallel-programming/">&lt;p&gt;최근에 병렬 프로그래밍이 많은 관심을 받고 있다. 그 이유는 병렬 프로그래밍을 이용하면 비교적 저렴한 가격에 슈퍼컴퓨터의 성능을 얻을 수 있다는데 있다. 하지만 어떻게 해서 이런 일이 가능한지 우선 알아보도록 하자.&lt;/p&gt;

&lt;h2 id=&quot;gpu&quot;&gt;GPU&lt;/h2&gt;
&lt;p&gt;그래픽카드는 그래픽을 실제 출력장치에 그려주는 역할을 한다. 하지만 출력장치의 하나 하나의
 Pixel에 대해서 그래픽을 매칭시켜야 하기 때문에 디스플레이 기술이 발전할 수록 그래픽카드는 발전하였다. 그리고 그 그래픽카드에서 그래픽 처리를 하는 장치를  &lt;code class=&quot;highlighter-rouge&quot;&gt;GPU&lt;/code&gt; 라고 한다.
 많은 연산을 필요로하는 그래픽을 처리하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;GPU&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;와 구조가 많이 다르다. 아래 사진을 보면 명확하기 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://c1.staticflickr.com/9/8258/29792623136_23e4bd3294_b.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;GPU가 CPU보다 엄청나게 많은 량의 ALU를 가지고 있는 것을 알 수 있다. CPU는 순차(Sequantial)적인 프로그램을 실행할 때는 좋은 성능을 발휘하지만, 대용량 처리에는 약하다. 그래서 GPU의 수많은 core들에 thread를 돌리면 데이터를 CPU보다 훨씬 빨리 처리할 수 있게 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;예를 들자면 n x n 의 matrix가 있다고 하면 이 matrix의 합을 구할 때는 보통 컴퓨터로는 O(n^2)이라는 시간이 소요된다. 하지만, n x n core를 가진 GPU로 병렬 프로그래밍을 하게 된다면 이 연산이 O(1) 시간만에 끝나게 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;왜 최근에 들어 병렬 프로그래밍이 관심을 받고 있나?&lt;/h2&gt;
&lt;p&gt;이유는 간단하다. 빅데이터의 시대와 고품질 멀티미디어의 세계가 시작되면서 대용량 데이터에 대한 처리의 중요성이 커져서 그렇다.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;병렬 프로그래밍 시작&lt;/h2&gt;
&lt;p&gt;하지만 이 강력한 병렬 컴퓨팅도 병렬 프로그래밍을 할 줄 모른다면 아무 의미가 없다. 그래서 NDIVIA의 &lt;code class=&quot;highlighter-rouge&quot;&gt;CUDA(Compute Unified Device Architecture)&lt;/code&gt;를 공부하면서 병렬 프로그래밍을 공부하고자 한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;CUDA&lt;/code&gt;는 NDIVIA에서 만들어서 NDIVIA 그래픽카드(GeForce)를 장착한 컴퓨터에서만 돌어아간다고 한다.. &lt;code class=&quot;highlighter-rouge&quot;&gt;CUDA&lt;/code&gt;에 좀 익숙해지면 &lt;code class=&quot;highlighter-rouge&quot;&gt;OpenCL&lt;/code&gt;도 해볼 생각이다.&lt;/p&gt;</content><author><name>   Hoseung</name><email>astrohsy@gmail.com</email></author><category term="parallel" /><category term="cuda" /><summary>최근에 병렬 프로그래밍이 많은 관심을 받고 있다. 그 이유는 병렬 프로그래밍을 이용하면 비교적 저렴한 가격에 슈퍼컴퓨터의 성능을 얻을 수 있다는데 있다. 하지만 어떻게 해서 이런 일이 가능한지 우선 알아보도록 하자.</summary></entry><entry><title>Three.js로 시작하는 WebGL - 1</title><link href="http://astrohsy.com/webgl/threejs-intro-1/" rel="alternate" type="text/html" title="Three.js로 시작하는 WebGL - 1" /><published>2016-09-18T00:00:00+09:00</published><updated>2016-09-18T00:00:00+09:00</updated><id>http://astrohsy.com/webgl/threejs-intro-1</id><content type="html" xml:base="http://astrohsy.com/webgl/threejs-intro-1/">&lt;p&gt;나는 프로젝트에서 3D 모델 stl파일을 웹에서 보여주는 작업을 해야하기 때문에 threejs를 배우기 시작하였다. 이제 threejs 관련 몇몇 글을 번역하면서
배운다는 생각으로 글도 포스팅 해 볼생각이다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://treehouse-code-samples.s3.amazonaws.com/threejs_logo_example/threejs_logo_example.zip&quot;&gt;ㅅ샘플코드&lt;/a&gt;;&lt;/p&gt;

&lt;h2 id=&quot;html-&quot;&gt;설치 및 HTML파일 생성&lt;/h2&gt;
&lt;p&gt;우선 &lt;code class=&quot;highlighter-rouge&quot;&gt;Three.js&lt;/code&gt;를 사용하기 위해서 다운로드를 받아야한다. (http://threejs.org/) 에서 다운을 받고, 다운 받을 폴더를 작업하고자 하는 폴더안에 삽입한다. 다운 받은 폴더 안에 build폴더와 example 폴더가 있을 것이다. 편의를 위해서 나같은 경우 각 폴더의 파일들을 js폴더를 만들어서 넣었다. 그래서 여기에 작성된 코드들은 js폴더가 있다는 가정하에 작성하겠다.&lt;/p&gt;

&lt;p&gt;그러면 프로젝트 폴더안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt; 파일을 다음과 같이 만든다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!doctype html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src =&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;js/three.min.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src =&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;js/orbitControls.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;scene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;camera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;renderer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;animate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;여기에는&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;D&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;코드&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;작성&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;scene-&quot;&gt;Scene 만들기&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Three.js&lt;/code&gt;에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;scene&lt;/code&gt; 개념을 정의했다. &lt;code class=&quot;highlighter-rouge&quot;&gt;scene&lt;/code&gt;은 우리가 넣고자 객체(&lt;code class=&quot;highlighter-rouge&quot;&gt;Camera&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Geometry&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Lights&lt;/code&gt;…) 하는 곳의 위치를 정의하는 것이다.
그리고 이미지를 보여줄 화면의 크기를 구하기 위해서 browser의 window의 크기는 &lt;code class=&quot;highlighter-rouge&quot;&gt;WIDTH&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;HEIGHT&lt;/code&gt;에 저장한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;scene&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;THREE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Scene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;WIDTH&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;HEIGHT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;wndwo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;render-&quot;&gt;Render 만들기&lt;/h2&gt;
&lt;p&gt;Render는 그래픽을 실제로 화면에 보여주는 일을 한다.
canvas 및 SVG의 Render를 사용할 수 있지만, GPU를 활용하여 빠르게 Render하기 위해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;WebGL renderer&lt;/code&gt;를 활용한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//이전 코드&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;renderer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;THREE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;WebGLRenderer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;antialias&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;renderer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;WIDTH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;HEIGHT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Render할 크기&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;renderer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;domElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//HTML에 삽입&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//다음 코드&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Javascript로 DOM을 html body안에 삽입한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;renderer.domElement&lt;/code&gt; 호출로 Three.js는 &lt;code class=&quot;highlighter-rouge&quot;&gt;canvas&lt;/code&gt;를  body안에 삽입할 것 이다.&lt;/p&gt;

&lt;h2 id=&quot;camera-&quot;&gt;Camera 만들기&lt;/h2&gt;
&lt;p&gt;이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;Camera&lt;/code&gt;를 만들어야할 차례이다. 우리는 &lt;code class=&quot;highlighter-rouge&quot;&gt;PerspectiveCamera&lt;/code&gt;를 쓸 것이고 이는 다음과 같은 파라미터들을 가진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FOV - 보는 각도&lt;/li&gt;
  &lt;li&gt;Apsect - aspect ratio를 구하기 위해서 brower width 에서 broser height를 나눈다.&lt;/li&gt;
  &lt;li&gt;Near - scene object와 Camera의 거리를 나타낸다.&lt;/li&gt;
  &lt;li&gt;Far - 볼 수 있는 거리를 지정한다. 이 거리를 넘는 객체들은 보이지 않느다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Camera&lt;/code&gt;를 생성한 다음에는 카메라의 위치를 (X, Y, Z) 좌표로 지정해야한다. default는 (0, 0, 0)이고, 이 예제에서는 Mesh와 Camera사이에 거리를 두기 위해서 (0, 6, 0)으로 지정한다. 그리고 마지막으로 Camera를 Scene에 추가하면 된다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//이전 코드&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;camera&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;THREE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;PerspectiveCamera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;WIDTH&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;HEIGHT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;camera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;scene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;camera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//다음 코드&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;lighting-&quot;&gt;Lighting 추가&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PointLight&lt;/code&gt; 객체를 &lt;code class=&quot;highlighter-rouge&quot;&gt;Scene&lt;/code&gt;에 추가를 해야하만 우리가 추가한 3D Object를 볼 수 있도록 된다.(Light는 사방을 비춘다.) &lt;code class=&quot;highlighter-rouge&quot;&gt;PointLight&lt;/code&gt;는 다음 과 같은 Parameter를 같는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;color&lt;/code&gt; - Light의 RGB값의 16진수 표현&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;intensity&lt;/code&gt; - Light의 세기&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;distance&lt;/code&gt; - Light의 길이&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;decay&lt;/code&gt; - Light가 가면서 어두어지는 정도&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//이전 코드&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// scene의 배경 색&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;renderer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setClearColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x333F47&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;light&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;THREE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;PointLight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0xffffff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;light&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;scene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;camera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//다음 코드&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;controls-&quot;&gt;Controls 추가&lt;/h2&gt;

&lt;p&gt;이 Controls는 처음에 &lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt;에 추가한 &lt;code class=&quot;highlighter-rouge&quot;&gt;orbit controls&lt;/code&gt; 안의 함수이다.
반드시 해야하는 것은 아니지만, 이는 우리가 마우스 조작으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Mesh&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;Orbit&lt;/code&gt;을 조작할 수 있게 해준다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//이전 코드&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;controls&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;THREE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;OrbitControls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;camera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;renderer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;domElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//다음 코드&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;scene-render&quot;&gt;Scene Render하기&lt;/h2&gt;

&lt;p&gt;초기화 함수를 &lt;code class=&quot;highlighter-rouge&quot;&gt;init()&lt;/code&gt;을 실행하고 난 다음, 애니메이션 함수인 ‘animation()’을 실행 시켜야한다. 왜냐하면, 위의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Controls&lt;/code&gt;에서 추가한 조작을 할 때마다 새로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Mesh&lt;/code&gt;를 다시 &lt;code class=&quot;highlighter-rouge&quot;&gt;Render&lt;/code&gt;를 해주어야 하기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;requestAnimationFrame()&lt;/code&gt; 함수는 여러 장점이 있지만, 불필요하게 다시 애니메이션을 그리는 일을 방지해주는 기능을 한다. 이 함수를 재귀 구조로 돌리면서 다시 &lt;code class=&quot;highlighter-rouge&quot;&gt;Mesh&lt;/code&gt;를 그려준다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//이전 코드&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;requestAnimationFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;animate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Render The Scene&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;renderer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;scene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;camera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;controls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;section&quot;&gt;출처&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.teamtreehouse.com/the-beginners-guide-to-three-js&quot;&gt;TreeHouse&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;기타&lt;/h2&gt;
&lt;p&gt;다음 글에서는 다른 예제를 번역해보도록 하겠다.&lt;/p&gt;</content><author><name>   Hoseung</name><email>astrohsy@gmail.com</email></author><category term="threejs" /><category term="webgl" /><summary>나는 프로젝트에서 3D 모델 stl파일을 웹에서 보여주는 작업을 해야하기 때문에 threejs를 배우기 시작하였다. 이제 threejs 관련 몇몇 글을 번역하면서
배운다는 생각으로 글도 포스팅 해 볼생각이다.</summary></entry><entry><title>깃허브(Github) 기초적인 사용법</title><link href="http://astrohsy.com/github/githubintro/" rel="alternate" type="text/html" title="깃허브(Github) 기초적인 사용법" /><published>2016-09-17T00:00:00+09:00</published><updated>2016-09-17T00:00:00+09:00</updated><id>http://astrohsy.com/github/githubintro</id><content type="html" xml:base="http://astrohsy.com/github/githubintro/">&lt;p&gt;최근 학교에서 강제로 Github를 쓰도록하고 있다… 그래서 이 포스트에선 깃허브를 배우면서 알게된 기초적인 사용설명을 설명해보고자 한다.
우선 왜 깃허브를 쓰는지에 대해 말하자면 프로젝트를 진행할 때, 반드시 프로젝트의 버전 관리를 하여야한다. 그래야만 나중에 프로젝트 진행 중에 문제가 생길시 되돌릴 수가 있고, 프로젝트가 어느정도로 진행되었는지 알 수 있기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;git&quot;&gt;깃(Git)&lt;/h2&gt;
&lt;p&gt;이런 버전 관리 툴은 이미 많이 존재하지만, 최근에 가장 많이 사용하는 툴은 깃(Git)이다. 그 이유는 다른 버전 관리 툴과 다르게 “분산(Distributed)”을 하기 때문이다. 분산을 통해 버전 기록과 통합을 별도로 진행을 해서 프로젝트의 자유도를 높일 수가 있다고 한다. 각자의 버전 기록을 할 때는 commit을 하고, 통합이 필요할 때만 push를 함으로써 기록하면 되기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;github&quot;&gt;깃허브(Github)&lt;/h2&gt;
&lt;p&gt;깃허브는 깃을 이용한 프로젝트를 웹에 호스팅할 수 있도록 하는 것이다. 깃 자체는 Local에 기록을 하는데, 깃허브를 사용함으로써 이제 한 자리에 없어도 같이 프로젝트를 진행할 수 있도록 된 것이다. 다른 호스팅 사이트도 있지만, 깃허브가 가장 유명하다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;기초적인 사용 방법&lt;/h2&gt;
&lt;p&gt;만약에 git command가 없다고 뜬다면 &lt;a href=&quot;https://git-scm.com/&quot;&gt;이곳에서 설치한다&lt;/a&gt;
#### 1. 새로운 프로젝트를 만들 때
* 프로젝트를 진행하기 전에 깃허브에 들어가서 repository를 만들어야한다.
깃허브에서 New repository 버튼을 눌러 repository를 만든다.
* 생성된 repository안에 들어가서 초록색 clone or download 버튼을 클릭한 다음 나타는 링크를 복사한다.
* 프로젝트를 만들고 싶은 경로를 Command 창으로 들어간다.
* 복사한 주소가 만약 “https://github.com/astrohsy/blog.git”이라면 다음을 커맨드창에 입력한다.&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt; git clone https://github.com/astrohsy/blog.git &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2. 기존 프로젝트를 깃허브에 올릴 때&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;프로젝트를 진행하기 전에 깃허브에 들어가서 repository를 만들어야한다.
깃허브에서 New repository 버튼을 눌러 repository를 만든다.&lt;/li&gt;
  &lt;li&gt;생성된 repository안에 들어가서 초록색 clone or download 버튼을 클릭한 다음 나타는 링크를 복사한다.&lt;/li&gt;
  &lt;li&gt;프로젝트를 만들고 싶은 경로를 Command 창으로 들어간다.&lt;/li&gt;
  &lt;li&gt;복사한 주소가 만약 “https://github.com/astrohsy/blog.git”이라면 다음을 커맨드 창에 입력한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;git remote add origin https://github.com/astrohsy/blog.git
git add .
git commit -am &lt;span class=&quot;s2&quot;&gt;&quot;first commit&quot;&lt;/span&gt;
git push origin master&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;section-2&quot;&gt;3. 자신의 변경이력을 저장할 때&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;프로젝트 폴더안에 들어가서 Command 창에 들어간다.&lt;/li&gt;
  &lt;li&gt;만약에 새로 생성한 파일이 있을 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;git add . &lt;span class=&quot;c&quot;&gt;# 만약에 특정 파일만 추가하고 싶으면 해당 파일의 경로를 적는다.&lt;/span&gt;
git commit -am &lt;span class=&quot;s2&quot;&gt;&quot;여기에 수정 내역을 적는다&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;따로 없는 경우에는&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;git commit -am &lt;span class=&quot;s2&quot;&gt;&quot;여기에 수정 내역을 적는다&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;section-3&quot;&gt;4. 자신의 변경이력을 프로젝트랑 합칠 때&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;프로젝트 폴더안에 들어가서 Command 창에서&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;git push origin master&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;section-4&quot;&gt;주의사항&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;같은 파일을 동시에 작업하지 않는 것이 좋다. 같이 하게되면 나중에 conflict가 생기는데 이것을 merge할려면 골치 아프다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;참조자료&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/benelog/2922437&quot;&gt;버전 관리 시스템 유랑기, 그리고 Git 적응기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://backlogtool.com/git-guide/kr/&quot;&gt;Backlogtool git-guide&lt;/a&gt; &amp;lt;- 강추!&lt;/p&gt;</content><author><name>   Hoseung</name><email>astrohsy@gmail.com</email></author><category term="github" /><category term="project" /><summary>최근 학교에서 강제로 Github를 쓰도록하고 있다… 그래서 이 포스트에선 깃허브를 배우면서 알게된 기초적인 사용설명을 설명해보고자 한다.
우선 왜 깃허브를 쓰는지에 대해 말하자면 프로젝트를 진행할 때, 반드시 프로젝트의 버전 관리를 하여야한다. 그래야만 나중에 프로젝트 진행 중에 문제가 생길시 되돌릴 수가 있고, 프로젝트가 어느정도로 진행되었는지 알 수 있기 때문이다.</summary></entry><entry><title>동적계획법(Dynamic Programming) - 개념</title><link href="http://astrohsy.com/algorithm/dynamic-programming-1/" rel="alternate" type="text/html" title="동적계획법(Dynamic Programming) - 개념" /><published>2016-09-16T00:00:00+09:00</published><updated>2016-09-16T00:00:00+09:00</updated><id>http://astrohsy.com/algorithm/dynamic-programming-1</id><content type="html" xml:base="http://astrohsy.com/algorithm/dynamic-programming-1/">&lt;h2 id=&quot;dpdynamic-programming&quot;&gt;DP(Dynamic Programming)?&lt;/h2&gt;
&lt;p&gt;DP는 문제를 최적화를 할 때, 사용을 주로 합니다. 불필요하게 다시 계산을 하는 일을 막아 주는 기능을 합니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 가장 기본 적인 Fibonacci(피보나치) 숫자를 구하는 경우를 생각해 봅시다. 여기서 가장 단순하게 생각할 수 있는 코드는 피보나치는&lt;/p&gt;

&lt;p&gt;f(n) = f(n-1) + f(n-2) 즉 n번째 피보나치 숫자는 n-1번 째 피보나치 수와 n-2번 째 피보나치 수의 합과 같다 입니다.&lt;/p&gt;

&lt;p&gt;이를 재귀 함수로 나타내면&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;nth_fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nth_fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nth_fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;입니다. 하지만 이와 같은 경우 치명적인 문제점이 있습니다. 10에 가까운 숫자를 가지고 직접 저 알고리즘을 나무 형태로 그리면서 따라가 보시기 바랍니다.&lt;/p&gt;

&lt;p&gt;그럼 문제점을 찾으셨을 겁니다. 이미 무슨 값인지 계산했던 피보나치 수를 다시 계산을 하는 것을 보게 됩니다. 그래서 이 같은 경우 항상 O(2^n) 이라는 어마어마한 연산을 하여야 합니다.&lt;/p&gt;

&lt;p&gt;이 경우를 최적화할 수 있는 기법이 DP입니다. 그리고 DP에는 두 가지 대표적인 구현 방법이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;dp&quot;&gt;메모이제이션을 이용한 DP&lt;/h2&gt;
&lt;p&gt;메모이제이션을 이용한 DP는 간단하게 말하면 이미 계산한 값은 기록을 해놔서 다시는 다시 계산을 안하도록 하는 것 입니다. 위의 코드에서 살짝만 바꾸면 최적화가 됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 기록해 두는 배열
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nth_fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 첫 번째와 두 번째 피보나치는 1
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nth_fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nth_fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 코드를 보면 다음 줄들이 변경이 되었습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1
&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3
&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nth_fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nth_fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 4
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;우선 1번은 기록을 해놓기 위해서 선언한 배열입니다. 2번은 C++에서 레퍼런스입니다. 단순히 변수의 값을 카피하는 것이 아니라, 변수의 주소 자체를 카피를 해서 ret이 변하면 D[n]의 값도 바뀌도록 해주는 것 입니다.
그리고 3번은 이미 계산을 한 상태면 D[n]의 값은 0이 아니므로 0이 아니면 이미 계산해 둔 값을 반환하도록 하는 것 입니다.
그리고 4번이 중요한데, 4번은 재귀로 밑에 값을 계산을 하고 그 값을 ret에 저장하는 것 입니다.
이렇게 코드를 짜면 겹치는 부분은 다시 연산하지 않게 됩니다.&lt;/p&gt;

&lt;p&gt;이 경우에는 최악 경우에도 선언을 해둔 배열의 크기만큼만 연산을 합니다. 그래서 O(n) // n은 배열의 크기
와 같은 시간 복잡도를 같습니다.&lt;/p&gt;

&lt;h2 id=&quot;dp-1&quot;&gt;반복문을 이용한 DP&lt;/h2&gt;
&lt;p&gt;하지만 메모이제이션을 활용한 DP를 활용하지 못할 때도 있습니다. 함수의 깊이가 너무 깊어져서 Stack Overflow가 나거나, 반복문을 이용하는 것이 훨씬 간편할 때 입니다.&lt;/p&gt;

&lt;p&gt;메모이제이션을 이용한 DP에서는 위에서 아래(Top-Down)로 진행을 했다면 반복문을 이용한 DP는 아래서 위로(Bottom-Up) 방식을 사용합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 기록해 두는 배열
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nth_fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 첫 번째와 두 번째 피보나치는 1
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이렇게 어떻게 보면 메모이제이션 예제보다 더욱 간단하게 구현이 되었습니다. 그리고 함수를 계속 호출하지 않아서 메모리를 절약할 수도 있습니다. 실제로 약간 빠르기도 합니다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;마치며&lt;/h2&gt;

&lt;p&gt;반복문을 이용한 DP에서 n번째 피보나치 수를 구할 때, 기록하는 배열을 모두 잡을 필요가 없습니다. 변수 3개를 한 스텝마다 갱신을 하면서 구해서 메모리를 더욱 절약할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 본격적인 DP문제는 다음 글부터 다루도록 하겠습니다.&lt;/p&gt;</content><author><name>   Hoseung</name><email>astrohsy@gmail.com</email></author><category term="dynamic programming" /><summary>DP(Dynamic Programming)?
DP는 문제를 최적화를 할 때, 사용을 주로 합니다. 불필요하게 다시 계산을 하는 일을 막아 주는 기능을 합니다.</summary></entry><entry><title>제 2회 삼성 프로그래밍 경진대회(SCPC) 참가 후기</title><link href="http://astrohsy.com/contest/scpc2016/" rel="alternate" type="text/html" title="제 2회 삼성 프로그래밍 경진대회(SCPC) 참가 후기" /><published>2016-09-13T00:00:00+09:00</published><updated>2016-09-13T00:00:00+09:00</updated><id>http://astrohsy.com/contest/scpc2016</id><content type="html" xml:base="http://astrohsy.com/contest/scpc2016/">&lt;h2 id=&quot;scpc&quot;&gt;SCPC&lt;/h2&gt;
&lt;p&gt;삼성에서 개최하는 작년부터 개최하기 시작한 대학생과 대학원생이 참가 가능한 알고리즘 대회이다.
1차와 2차는 온라인으로 진행되었고, 본선은 우면동에 위치한 삼성전자 건물에서 진행이 되었다.&lt;/p&gt;

&lt;p&gt;나는 운이 좋게도 2차 예선에서 A, B와 C 부분 점수를 맞았는데 제출 횟수가 적어서인지 본선 진출 대상자가 되었다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;본선 대회 전&lt;/h2&gt;
&lt;p&gt;대회가 진행하기 전에 대회장 앞에 여러 이벤트 부스들이 배치되어 있었다. 미니게임과 QR코드를 활용한 Quiz프로그램이 있었고, 기어s2와 다른 여러 상품을 제공하였다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/scpc1.jpg&quot; alt=&quot;Image description&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/scpc3.jpg&quot; alt=&quot;Image description&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;대회&lt;/h2&gt;
&lt;p&gt;대회 문제는 확실히 1차, 2차 예선문제보다는 난이도가 있었다. 대회를 치르고 나서 아직 나는 아직 알고리즘 공부가 많이 부족하다는 것을 깨닳았다. 대회문제는 아마도 &lt;a href=&quot;http://codeground.org&quot;&gt;Codeground&lt;/a&gt;에 올라와 있을 것 이다.
1번 마땅한 해결책이 생각나지 않아 2번 째, 테스트 그룹까지만 득점하였고, 2번 문제는 어떻게 푸는지는 알았는데, 코딩으로 옮기는 도중에 실수가 있었는지, 계속 부분점수만 받았다..&lt;/p&gt;

&lt;p&gt;대회 끝나고 말들을 들어보니 내 접근이 맞았었다. 코딩으로 옮기는 연습이 더욱 필요한 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;대회 후&lt;/h2&gt;
&lt;p&gt;30명 정도의 상위 득점자들의 수상식을 진행하고, 대회가 종료가 되었다. 삼성전자 신종균 대표이사가 대회를 찾아오셔서 많이 놀랐다. 세삼 이 대회가 큰 대회라는 것을 실감하였다.&lt;/p&gt;

&lt;p&gt;대회가 끝나고, 대회에서 사용했던 청축식 기계식 키보드와 마우스패드 또, 키보드가 들어갈 수 있는 에코백을 주었다. 비록 올해는 좋은 성과를 거두지 못했지만, 다음에 기회가 된다면 더욱 열심히 해서 좋은 성과를 거두고 싶다.&lt;/p&gt;</content><author><name>   Hoseung</name><email>astrohsy@gmail.com</email></author><category term="scpc" /><summary>SCPC
삼성에서 개최하는 작년부터 개최하기 시작한 대학생과 대학원생이 참가 가능한 알고리즘 대회이다.
1차와 2차는 온라인으로 진행되었고, 본선은 우면동에 위치한 삼성전자 건물에서 진행이 되었다.</summary></entry><entry><title>SW개발병, 소프트웨어개발병 지원 후기</title><link href="http://astrohsy.com/life/sw-develop-soldier-interview/" rel="alternate" type="text/html" title="SW개발병, 소프트웨어개발병 지원 후기" /><published>2016-09-12T00:00:00+09:00</published><updated>2016-09-12T00:00:00+09:00</updated><id>http://astrohsy.com/life/sw-develop-soldier-interview</id><content type="html" xml:base="http://astrohsy.com/life/sw-develop-soldier-interview/">&lt;h2 id=&quot;section&quot;&gt;지원동기&lt;/h2&gt;
&lt;p&gt;우연히 병무청 홈페이지를 둘러보았는데, S/W개발병 모집공고가 눈에 들어왔다. 군대 문제로 머리가 아팠던 나는 군대에서도 프로그래밍을 까먹지 않고, 오히려 더 배울 수 있다는 생각에 S/W개발병 서류 지원을 하게 되었다.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;서류접수&lt;/h2&gt;
&lt;p&gt;옛날과는 달리 S/W개발병 지원 자격이 많이 달라졌다. 그전에 SW개발병 후기로 올라온 글들을 보면 “자격증 소지자”나 “2년 이상 컴퓨터 관련 전공을 한 자” 였지만, 아마도 2016년도 1차 모집부터 지원자격이 다음과 같이 바겼다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MOU체결기관(소프트웨어 마에스트로, Best of Best)&lt;/li&gt;
  &lt;li&gt;소프트웨어 경진대회 및 정보보안대회 수상자&lt;/li&gt;
  &lt;li&gt;동아리나 연구실에서 SW프로젝트를 수행한 자&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;지원자격을 보면 많이 까다로워졌다. 아마도 그전 선발 방식에서는 SW개발 경험이 별로 없었던 사람들도 많이 선발이 되어서 문제가 되었나보다.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;서류합격&lt;/h2&gt;
&lt;p&gt;막 개학을 해서 정신이 없었던 나는 문자 한 통을 받았다. SW개발병 서류전형에 합격하였고, 용산역 부근으로 면접보러 오라는 문자였다.&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;면접&lt;/h2&gt;
&lt;p&gt;새벽같이 기차를 타고 용산역 부근으로 면접을 치러 갔다. 면접을 여러 날로 나눠서 치는 것 같았다. 그리고 면접 시간 외 시간이 예상 했던 것보다 많이 길어서 당황했다. 심리 테스트를 보고 점심을 먹고 다시 면접을 보러 갔다.&lt;/p&gt;

&lt;p&gt;돌아가서 좀 기달리자, 면접이 시작되었다. 면접관님들은 모두 5명 이였다. 지원자 4명이 같이 면접을 보러 들어갔다.&lt;/p&gt;

&lt;p&gt;질문은 다음과 같은 것들이 나왔다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;안보관&lt;/li&gt;
  &lt;li&gt;지원동기&lt;/li&gt;
  &lt;li&gt;자기가 개발한 대표적인 소프트웨어 설명&lt;/li&gt;
  &lt;li&gt;군대 생활 관련&lt;/li&gt;
  &lt;li&gt;자기소개서를 보고 하는 질문&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;면접은 무난하게 끝나고 돌아왔다.
면접같은 경우는 따로 준비할 필요는 없고, 자기가 개발한 소프트웨어에 대한 내용을 다시 한 번 상기시켜보면 충분할 것 같다.&lt;/p&gt;</content><author><name>   Hoseung</name><email>astrohsy@gmail.com</email></author><category term="군인" /><category term="sw개발병" /><category term="면접" /><summary>지원동기
우연히 병무청 홈페이지를 둘러보았는데, S/W개발병 모집공고가 눈에 들어왔다. 군대 문제로 머리가 아팠던 나는 군대에서도 프로그래밍을 까먹지 않고, 오히려 더 배울 수 있다는 생각에 S/W개발병 서류 지원을 하게 되었다.</summary></entry><entry><title>최소공배수와 최대공약수 구하기</title><link href="http://astrohsy.com/algorithm/gcd/" rel="alternate" type="text/html" title="최소공배수와 최대공약수 구하기" /><published>2016-09-10T00:00:00+09:00</published><updated>2016-09-10T00:00:00+09:00</updated><id>http://astrohsy.com/algorithm/gcd</id><content type="html" xml:base="http://astrohsy.com/algorithm/gcd/">&lt;h2 id=&quot;section&quot;&gt;유클리드 호제법&lt;/h2&gt;
&lt;p&gt;두 양의 정수 a, b에 대해서 b = aq + r (0 &amp;lt;= r &amp;lt; a)라 하면 a, b의 최대 공약수는 a, r의 최대 공약수와 같다는 원리이다.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;최대공약수를 구하는 방법&lt;/h2&gt;
&lt;p&gt;유클리드 호제법으로 재귀와 반복문을 이용하여서 최대공약수(Greatest Common Divisor)를 구하는 알고리즘을 구현할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.재귀함수를 이용한 구현&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;gcd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// b == 0이면 더 이상 최대공약수를 갖지 않기 때문에 a를 반환한다.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gcd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 유클리드 호제법을 활용하여서 a, b의 최대 공약수를 b, r(a%b)로 치환한다.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;section-3&quot;&gt;2.반복문을 이용한 구현&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;section-4&quot;&gt;최소공배수를 구하는 방법&lt;/h2&gt;
&lt;p&gt;최소공배수(Least Common Multiple)는 최대공약수를 구하면 거의 다 구한 값이다. &lt;br /&gt;
서로 곱한 값에서 공통이 부분만 제외해주면 된다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// gcd는 a, b의 최대공약수이다.
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lcm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gcd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name>   Hoseung</name><email>astrohsy@gmail.com</email></author><category term="gcd" /><category term="lcd" /><category term="최대공약수" /><category term="최소공배수" /><category term="유클리드호제법" /><summary>유클리드 호제법
두 양의 정수 a, b에 대해서 b = aq + r (0 &amp;lt;= r &amp;lt; a)라 하면 a, b의 최대 공약수는 a, r의 최대 공약수와 같다는 원리이다.</summary></entry></feed>
