<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ShootingBugs</title>
    <description>참가한 대회와 알고리즘과 머신러닝에 대한 내용들을 올릴 생각입니다.</description>
    <link>http://astrohsy.com/</link>
    <atom:link href="http://astrohsy.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 18 Sep 2016 23:56:13 +0900</pubDate>
    <lastBuildDate>Sun, 18 Sep 2016 23:56:13 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>threejs로 시작하는 WebGL - 1</title>
        <description>&lt;p&gt;나는 프로젝트에서 3D 모델 stl파일을 웹에서 보여주는 작업을 해야하기 때문에 threejs를 배우기 시작하였다. 이제 threejs 관련 몇몇 글을 번역하면서
배운다는 생각으로 글도 포스팅 해 볼생각이다.&lt;/p&gt;

&lt;h2 id=&quot;html-&quot;&gt;설치 및 HTML파일 생성&lt;/h2&gt;
&lt;p&gt;우선 three.js를 사용하기 위해서 다운로드를 받아야한다. (http://threejs.org/) 에서 다운을 받고, 다운 받을 폴더를 작업하고자 하는 폴더안에 삽입한다. 다운 받은 폴더 안에 build폴더와 example 폴더가 있을 것이다. 편의를 위해서 나같은 경우 각 폴더의 파일들을 js폴더를 만들어서 넣었다. 그래서 여기에 작성된 코드들은 js폴더가 있다는 가정하에 작성하겠다.&lt;/p&gt;

&lt;p&gt;그러면 프로젝트 폴더안에 index.html 파일을 다음과 같이 만든다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!doctype html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src =&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;js/three.min.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src =&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;js/orbitControls.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;여기에는&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;D&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;코드&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;작성&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;scene-&quot;&gt;Scene 만들기&lt;/h2&gt;
&lt;p&gt;Three.js에서는 &lt;strong&gt;&lt;em&gt;scene&lt;/em&gt;&lt;/strong&gt; 개념을 정의했다. __&lt;em&gt;scene&lt;/em&gt;__은 우리가 넣고자 객체(Camera, Geometry, Lights…) 하는 곳의 위치를 정의하는 것이다.
그리고 brower의 window의 크기는 __WIDTH__와 __HEIGHT__에 저장한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;scene&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;THREE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Scene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;WIDTH&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;HIEGHT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;wndwo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;render-&quot;&gt;Render 만들기&lt;/h2&gt;
&lt;p&gt;Render는 그래픽을 실제로 화면에 보여주는 일을 한다.
canvas 및 SVG의 Render를 사용할 수 있지만, GPU를 활용하여 빠르게 Render하기 위해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;WebGL renderer&lt;/code&gt;를 활용한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//이전 코드&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;renderer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;THREE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;WebGLRenderer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;antialias&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;renderer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;WIDTH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;HEIGHT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Render할 크기&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;renderer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;domElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//HTML에 삽입&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//다음 코드&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Javascript로 DOM을 html body안에 삽입한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;renderer.domElement&lt;/code&gt; 호출로 Three.js는 &lt;code class=&quot;highlighter-rouge&quot;&gt;canvas&lt;/code&gt;를  body안에 삽입할 것 이다.&lt;/p&gt;

&lt;h2 id=&quot;camera-&quot;&gt;Camera 만들기&lt;/h2&gt;
&lt;p&gt;이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;Camera&lt;/code&gt;를 만들어야할 차례이다. 우리는 &lt;code class=&quot;highlighter-rouge&quot;&gt;PerspectiveCamera&lt;/code&gt;를 쓸 것이고 이는 다음과 같은 파라미터들을 가진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FOV - 보는 각도&lt;/li&gt;
  &lt;li&gt;Apsect - aspect ratio를 구하기 위해서 brower width 에서 broser height를 나눈다.&lt;/li&gt;
  &lt;li&gt;Near - scene object와 Camera의 거리를 나타낸다.&lt;/li&gt;
  &lt;li&gt;Far - 볼 수 있는 거리를 지정한다. 이 거리를 넘는 객체들은 보이지 않느다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Camera&lt;/code&gt;를 생성한 다음에는 카메라의 위치를 (X, Y, Z) 좌표로 지정해야한다. default는 (0, 0, 0)이고, 이 예제에서는 Mesh와 Camera사이에 거리를 두기 위해서 (0, 6, 0)으로 지정한다. 그리고 마지막으로 Camera를 Scene에 추가하면 된다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//이전 코드&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;camera&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;THREE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;PerspectiveCamera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;WIDTH&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;HEIGHT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;camera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;scene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;camera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//다음 코드&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;— 작성중 —&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;출처&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.teamtreehouse.com/the-beginners-guide-to-three-js&quot;&gt;TreeHouse&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Sep 2016 00:00:00 +0900</pubDate>
        <link>http://astrohsy.com/webgl/threejs-intro-1/</link>
        <guid isPermaLink="true">http://astrohsy.com/webgl/threejs-intro-1/</guid>
        
        <category>threejs</category>
        
        <category>webgl</category>
        
        
        <category>WebGL</category>
        
      </item>
    
      <item>
        <title>깃허브(Github) 기초적인 사용법</title>
        <description>&lt;p&gt;최근 학교에서 강제로 Github를 쓰도록하고 있다… 그래서 이 포스트에선 깃허브를 배우면서 알게된 기초적인 사용설명을 설명해보고자 한다.
우선 왜 깃허브를 쓰는지에 대해 말하자면 프로젝트를 진행할 때, 반드시 프로젝트의 버전 관리를 하여야한다. 그래야만 나중에 프로젝트 진행 중에 문제가 생길시 되돌릴 수가 있고, 프로젝트가 어느정도로 진행되었는지 알 수 있기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;git&quot;&gt;깃(Git)&lt;/h2&gt;
&lt;p&gt;이런 버전 관리 툴은 이미 많이 존재하지만, 최근에 가장 많이 사용하는 툴은 깃(Git)이다. 그 이유는 다른 버전 관리 툴과 다르게 “분산(Distributed)”을 하기 때문이다. 분산을 통해 버전 기록과 통합을 별도로 진행을 해서 프로젝트의 자유도를 높일 수가 있다고 한다. 각자의 버전 기록을 할 때는 commit을 하고, 통합이 필요할 때만 push를 함으로써 기록하면 되기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;github&quot;&gt;깃허브(Github)&lt;/h2&gt;
&lt;p&gt;깃허브는 깃을 이용한 프로젝트를 웹에 호스팅할 수 있도록 하는 것이다. 깃 자체는 Local에 기록을 하는데, 깃허브를 사용함으로써 이제 한 자리에 없어도 같이 프로젝트를 진행할 수 있도록 된 것이다. 다른 호스팅 사이트도 있지만, 깃허브가 가장 유명하다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;기초적인 사용 방법&lt;/h2&gt;
&lt;p&gt;만약에 git command가 없다고 뜬다면 &lt;a href=&quot;https://git-scm.com/&quot;&gt;이곳에서 설치한다&lt;/a&gt;
#### 1. 새로운 프로젝트를 만들 때
* 프로젝트를 진행하기 전에 깃허브에 들어가서 repository를 만들어야한다.
깃허브에서 New repository 버튼을 눌러 repository를 만든다.
* 생성된 repository안에 들어가서 초록색 clone or download 버튼을 클릭한 다음 나타는 링크를 복사한다.
* 프로젝트를 만들고 싶은 경로를 Command 창으로 들어간다.
* 복사한 주소가 만약 “https://github.com/astrohsy/blog.git”이라면 다음을 커맨드창에 입력한다.&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt; git clone https://github.com/astrohsy/blog.git &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2. 기존 프로젝트를 깃허브에 올릴 때&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;프로젝트를 진행하기 전에 깃허브에 들어가서 repository를 만들어야한다.
깃허브에서 New repository 버튼을 눌러 repository를 만든다.&lt;/li&gt;
  &lt;li&gt;생성된 repository안에 들어가서 초록색 clone or download 버튼을 클릭한 다음 나타는 링크를 복사한다.&lt;/li&gt;
  &lt;li&gt;프로젝트를 만들고 싶은 경로를 Command 창으로 들어간다.&lt;/li&gt;
  &lt;li&gt;복사한 주소가 만약 “https://github.com/astrohsy/blog.git”이라면 다음을 커맨드 창에 입력한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;git remote add origin https://github.com/astrohsy/blog.git
git add .
git commit -am &lt;span class=&quot;s2&quot;&gt;&quot;first commit&quot;&lt;/span&gt;
git push origin master&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;section-2&quot;&gt;3. 자신의 변경이력을 저장할 때&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;프로젝트 폴더안에 들어가서 Command 창에 들어간다.&lt;/li&gt;
  &lt;li&gt;만약에 새로 생성한 파일이 있을 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;git add . &lt;span class=&quot;c&quot;&gt;# 만약에 특정 파일만 추가하고 싶으면 해당 파일의 경로를 적는다.&lt;/span&gt;
git commit -am &lt;span class=&quot;s2&quot;&gt;&quot;여기에 수정 내역을 적는다&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;따로 없는 경우에는&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;git commit -am &lt;span class=&quot;s2&quot;&gt;&quot;여기에 수정 내역을 적는다&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;section-3&quot;&gt;4. 자신의 변경이력을 프로젝트랑 합칠 때&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;프로젝트 폴더안에 들어가서 Command 창에서&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;git push origin master&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;section-4&quot;&gt;주의사항&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;같은 파일을 동시에 작업하지 않는 것이 좋다. 같이 하게되면 나중에 conflict가 생기는데 이것을 merge할려면 골치 아프다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;참조자료&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/benelog/2922437&quot;&gt;버전 관리 시스템 유랑기, 그리고 Git 적응기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://backlogtool.com/git-guide/kr/&quot;&gt;Backlogtool git-guide&lt;/a&gt; &amp;lt;- 강추!&lt;/p&gt;
</description>
        <pubDate>Sat, 17 Sep 2016 00:00:00 +0900</pubDate>
        <link>http://astrohsy.com/github/githubintro/</link>
        <guid isPermaLink="true">http://astrohsy.com/github/githubintro/</guid>
        
        <category>github</category>
        
        <category>project</category>
        
        
        <category>Github</category>
        
      </item>
    
      <item>
        <title>동적계획법(Dynamic Programming) 시작하기1</title>
        <description>&lt;h2 id=&quot;dpdynamic-programming&quot;&gt;DP(Dynamic Programming)?&lt;/h2&gt;
&lt;p&gt;DP는 문제를 최적화를 할 때, 사용을 주로 합니다. 불필요하게 다시 계산을 하는 일을 막아 주는 기능을 합니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 가장 기본 적인 Fibonacci(피보나치) 숫자를 구하는 경우를 생각해 봅시다. 여기서 가장 단순하게 생각할 수 있는 코드는 피보나치는&lt;/p&gt;

&lt;p&gt;f(n) = f(n-1) + f(n-2) 즉 n번째 피보나치 숫자는 n-1번 째 피보나치 수와 n-2번 째 피보나치 수의 합과 같다 입니다.&lt;/p&gt;

&lt;p&gt;이를 재귀 함수로 나타내면&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;nth_fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nth_fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nth_fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;입니다. 하지만 이와 같은 경우 치명적인 문제점이 있습니다. 10에 가까운 숫자를 가지고 직접 저 알고리즘을 나무 형태로 그리면서 따라가 보시기 바랍니다.&lt;/p&gt;

&lt;p&gt;그럼 문제점을 찾으셨을 겁니다. 이미 무슨 값인지 계산했던 피보나치 수를 다시 계산을 하는 것을 보게 됩니다. 그래서 이 같은 경우 항상 O(2^n) 이라는 어마어마한 연산을 하여야 합니다.&lt;/p&gt;

&lt;p&gt;이 경우를 최적화할 수 있는 기법이 DP입니다. 그리고 DP에는 두 가지 대표적인 구현 방법이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;dp&quot;&gt;메모이제이션을 이용한 DP&lt;/h2&gt;
&lt;p&gt;메모이제이션을 이용한 DP는 간단하게 말하면 이미 계산한 값은 기록을 해놔서 다시는 다시 계산을 안하도록 하는 것 입니다. 위의 코드에서 살짝만 바꾸면 최적화가 됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 기록해 두는 배열
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nth_fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 첫 번째와 두 번째 피보나치는 1
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nth_fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nth_fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 코드를 보면 다음 줄들이 변경이 되었습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1
&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3
&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nth_fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nth_fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 4
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;우선 1번은 기록을 해놓기 위해서 선언한 배열입니다. 2번은 C++에서 레퍼런스입니다. 단순히 변수의 값을 카피하는 것이 아니라, 변수의 주소 자체를 카피를 해서 ret이 변하면 D[n]의 값도 바뀌도록 해주는 것 입니다.
그리고 3번은 이미 계산을 한 상태면 D[n]의 값은 0이 아니므로 0이 아니면 이미 계산해 둔 값을 반환하도록 하는 것 입니다.
그리고 4번이 중요한데, 4번은 재귀로 밑에 값을 계산을 하고 그 값을 ret에 저장하는 것 입니다.
이렇게 코드를 짜면 겹치는 부분은 다시 연산하지 않게 됩니다.&lt;/p&gt;

&lt;p&gt;이 경우에는 최악 경우에도 선언을 해둔 배열의 크기만큼만 연산을 합니다. 그래서 O(n) // n은 배열의 크기
와 같은 시간 복잡도를 같습니다.&lt;/p&gt;

&lt;h2 id=&quot;dp-1&quot;&gt;반복문을 이용한 DP&lt;/h2&gt;
&lt;p&gt;하지만 메모이제이션을 활용한 DP를 활용하지 못할 때도 있습니다. 함수의 깊이가 너무 깊어져서 Stack Overflow가 나거나, 반복문을 이용하는 것이 훨씬 간편할 때 입니다.&lt;/p&gt;

&lt;p&gt;메모이제이션을 이용한 DP에서는 위에서 아래(Top-Down)로 진행을 했다면 반복문을 이용한 DP는 아래서 위로(Bottom-Up) 방식을 사용합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 기록해 두는 배열
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nth_fibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 첫 번째와 두 번째 피보나치는 1
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이렇게 어떻게 보면 메모이제이션 예제보다 더욱 간단하게 구현이 되었습니다. 그리고 함수를 계속 호출하지 않아서 메모리를 절약할 수도 있습니다. 실제로 약간 빠르기도 합니다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;마치며&lt;/h2&gt;

&lt;p&gt;반복문을 이용한 DP에서 n번째 피보나치 수를 구할 때, 기록하는 배열을 모두 잡을 필요가 없습니다. 변수 3개를 한 스텝마다 갱신을 하면서 구해서 메모리를 더욱 절약할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 본격적인 DP문제는 다음 글부터 다루도록 하겠습니다.&lt;/p&gt;
</description>
        <pubDate>Fri, 16 Sep 2016 00:00:00 +0900</pubDate>
        <link>http://astrohsy.com/algorithm/dynamic-programming-1/</link>
        <guid isPermaLink="true">http://astrohsy.com/algorithm/dynamic-programming-1/</guid>
        
        <category>dynamic programming</category>
        
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>제 2회 삼성 프로그래밍 경진대회(SCPC) 참가 후기</title>
        <description>&lt;h2 id=&quot;scpc&quot;&gt;SCPC&lt;/h2&gt;
&lt;p&gt;삼성에서 개최하는 작년부터 개최하기 시작한 대학생과 대학원이 참가 가능한 알고리즘 대회이다.
1차와 2차는 온라인으로 진행되었고, 본선은 우면동에 위치한 삼성전자 건물에서 진행이 되었다.&lt;/p&gt;

&lt;p&gt;나는 운이 좋게도 2차 예선에서 A, B와 C 부분 점수를 맞았는데 제출 횟수가 적어서인지 본선 진출 대상자가 되었다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;본선 대회 전&lt;/h2&gt;
&lt;p&gt;대회가 진행하기 전에 대회장 앞에 여러 이벤트 부스들이 배치되어 있었다. 미니게임과 QR코드를 활용한 Quiz프로그램이 있었고, 기어s2와 다른 여러 상품을 제공하였다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/scpc1.jpg&quot; alt=&quot;Image description&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/scpc3.jpg&quot; alt=&quot;Image description&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;대회&lt;/h2&gt;
&lt;p&gt;대회 문제는 확실히 1차, 2차 예선문제보다는 난이도가 있었다. 대회를 치르고 나서 아직 나는 아직 알고리즘 공부가 많이 부족하다는 것을 깨닳았다. 대회문제는 아마도 &lt;a href=&quot;http://codeground.org&quot;&gt;Codeground&lt;/a&gt;에 올라와 있을 것 이다.
1번 마땅한 해결책이 생각나지 않아 2번 째, 테스트 그룹까지만 득점하였고, 2번 문제는 어떻게 푸는지는 알았는데, 코딩으로 옮기는 도중에 실수가 있었는지, 계속 부분점수만 받았다..&lt;/p&gt;

&lt;p&gt;대회 끝나고 말들을 들어보니 내 접근이 맞았었다. 코딩으로 옮기는 연습이 더욱 필요한 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;대회 후&lt;/h2&gt;
&lt;p&gt;30명 정도의 상위 득점자들의 수상식을 진행하고, 대회가 종료가 되었다. 삼성전자 신종균 대표이사가 대회를 찾아오셔서 많이 놀랐다. 세삼 이 대회가 큰 대회라는 것을 실감하였다.&lt;/p&gt;

&lt;p&gt;대회가 끝나고, 대회에서 사용했던 청축식 기계식 키보드와 마우스패드 또, 키보드가 들어갈 수 있는 에코백을 주었다. 비록 올해는 좋은 성과를 거두지 못했지만, 다음에 기회가 된다면 더욱 열심히 해서 좋은 성과를 거두고 싶다.&lt;/p&gt;
</description>
        <pubDate>Tue, 13 Sep 2016 00:00:00 +0900</pubDate>
        <link>http://astrohsy.com/contest/scpc2016/</link>
        <guid isPermaLink="true">http://astrohsy.com/contest/scpc2016/</guid>
        
        <category>scpc</category>
        
        
        <category>Contest</category>
        
      </item>
    
      <item>
        <title>SW개발병, 소프트웨어개발병 지원 후기</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;지원동기&lt;/h2&gt;
&lt;p&gt;우연히 병무청 홈페이지를 둘러보았는데, S/W개발병 모집공고가 눈에 들어왔다. 군대 문제로 머리가 아팠던 나는 군대에서도 프로그래밍을 까먹지 않고, 오히려 더 배울 수 있다는 생각에 S/W개발병 서류 지원을 하게 되었다.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;서류접수&lt;/h2&gt;
&lt;p&gt;옛날과는 달리 S/W개발병 지원 자격이 많이 달라졌다. 그전에 SW개발병 후기로 올라온 글들을 보면 “자격증 소지자”나 “2년 이상 컴퓨터 관련 전공을 한 자” 였지만, 아마도 2016년도 1차 모집부터 지원자격이 다음과 같이 바겼다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MOU체결기관(소프트웨어 마에스트로, Best of Best)&lt;/li&gt;
  &lt;li&gt;소프트웨어 경진대회 및 정보보안대회 수상자&lt;/li&gt;
  &lt;li&gt;동아리나 연구실에서 SW프로젝트를 수행한 자&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;지원자격을 보면 많이 까다로워졌다. 아마도 그전 선발 방식에서는 SW개발 경험이 별로 없었던 사람들도 많이 선발이 되어서 문제가 되었나보다.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;서류합격&lt;/h2&gt;
&lt;p&gt;막 개학을 해서 정신이 없었던 나는 문자 한 통을 받았다. SW개발병 서류전형에 합격하였고, 용산역 부근으로 면접보러 오라는 문자였다.&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;면접&lt;/h2&gt;
&lt;p&gt;새벽같이 기차를 타고 용산역 부근으로 면접을 치러 갔다. 면접을 여러 날로 나눠서 치는 것 같았다. 그리고 면접 시간 외 시간이 예상 했던 것보다 많이 길어서 당황했다. 심리 테스트를 보고 점심을 먹고 다시 면접을 보러 갔다.&lt;/p&gt;

&lt;p&gt;돌아가서 좀 기달리자, 면접이 시작되었다. 면접관님들은 모두 5명 이였다. 지원자 4명이 같이 면접을 보러 들어갔다.&lt;/p&gt;

&lt;p&gt;질문은 다음과 같은 것들이 나왔다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;안보관&lt;/li&gt;
  &lt;li&gt;지원동기&lt;/li&gt;
  &lt;li&gt;자기가 개발한 대표적인 소프트웨어 설명&lt;/li&gt;
  &lt;li&gt;군대 생활 관련&lt;/li&gt;
  &lt;li&gt;자기소개서를 보고 하는 질문&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;면접은 무난하게 끝나고 돌아왔다.
면접같은 경우는 따로 준비할 필요는 없고, 자기가 개발한 소프트웨어에 대한 내용을 다시 한 번 상기시켜보면 충분할 것 같다.&lt;/p&gt;
</description>
        <pubDate>Mon, 12 Sep 2016 00:00:00 +0900</pubDate>
        <link>http://astrohsy.com/life/sw-develop-soldier-interview/</link>
        <guid isPermaLink="true">http://astrohsy.com/life/sw-develop-soldier-interview/</guid>
        
        <category>군인</category>
        
        <category>sw개발병</category>
        
        <category>면접</category>
        
        
        <category>Life</category>
        
      </item>
    
      <item>
        <title>최소공배수와 최대공약수을 구하는 알고리즘</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;유클리드 호제법&lt;/h2&gt;
&lt;p&gt;두 양의 정수 a, b에 대해서 b = aq + r (0 &amp;lt;= r &amp;lt; a)라 하면 a, b의 최대 공약수는 a, r의 최대 공약수와 같다는 원리이다.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;최대공약수를 구하는 방법&lt;/h2&gt;
&lt;p&gt;유클리드 호제법으로 재귀와 반복문을 이용하여서 최대공약수(Greatest Common Divisor)를 구하는 알고리즘을 구현할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.재귀함수를 이용한 구현&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;gcd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// b == 0이면 더 이상 최대공약수를 갖지 않기 때문에 a를 반환한다.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gcd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 유클리드 호제법을 활용하여서 a, b의 최대 공약수를 b, r(a%b)로 치환한다.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;section-3&quot;&gt;2.반복문을 이용한 구현&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;section-4&quot;&gt;최소공배수를 구하는 방법&lt;/h2&gt;
&lt;p&gt;최소공배수(Least Common Multiple)는 최대공약수를 구하면 거의 다 구한 값이다. &lt;br /&gt;
서로 곱한 값에서 공통이 부분만 제외해주면 된다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// gcd는 a, b의 최대공약수이다.
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lcm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gcd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

</description>
        <pubDate>Sat, 10 Sep 2016 00:00:00 +0900</pubDate>
        <link>http://astrohsy.com/algorithm/gcd/</link>
        <guid isPermaLink="true">http://astrohsy.com/algorithm/gcd/</guid>
        
        <category>gcd</category>
        
        <category>lcd</category>
        
        <category>최대공약수</category>
        
        <category>최소공배수</category>
        
        <category>유클리드호제법</category>
        
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>스택(Stack) 기본적인 사용 방법</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;개념&lt;/h2&gt;
&lt;p&gt;Stack은 가장 기본적이고 널리 쓰이고 있는 자료구조이다.
처음에 넣은 것은 마지막에 돌려주는 Last in First Out 즉, LIFO의 특성을 가진다.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;구현&lt;/h2&gt;
&lt;p&gt;기본적으로 다음과 같은 함수를 가지고 있으면 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;push(element)&lt;/li&gt;
  &lt;li&gt;pop()&lt;/li&gt;
  &lt;li&gt;isEmpty()&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;c--&quot;&gt;1.C언어를 이용한 구현(배열)&lt;/h3&gt;
&lt;p&gt;이 같은 경우 stack이라는 배열과 top이라는 변수가 필요하다. top 변수는 가장 위에 있는 원소를 가르키는 것이다.
처음에 top 초기값이 -1인 이유는 인덱스 0번째 자리에도 값이 들어가야하기 때문이다.
그리고 배열을 사용했기 때문에 top이 배열 크기를 넘어서지 않도록 조심해야한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;n&quot;&gt;MAX_STACK_SIZE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_STACK_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;top&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elemet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAX_STACK_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 가득 찼을 때 처리
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 가장 위에 있는 원소를 갱신한다.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 에러 처리
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//가장 위에 있는 원소를 반환하고 top을 한 칸 아래를 가르키도록 한다.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;c-stl--&quot;&gt;2.C++ STL을 이용한 구현&lt;/h3&gt;
&lt;p&gt;STL을 사용할려면 우리가 쓰고 싶은 자료구조를 include 시켜야한다.
보통 스택 구현과는 다르게 pop을 해도 값을 반환하지 않는다. 값을 읽을려면 top 함수를 써야한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stack&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//꺽쇠 안에 있는 것은 자기가 스택에서 쓰고자 하는 자료형이다.
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//구조체를 정의한 다음에 stack에 넣으면 그 자료형으로 스택을 사용할 수 있다.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// stack push 연산
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;top&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 스택에서 가장 위에 있는 Element를 엿보는 함수이다.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;top&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// stack의 pop 연산이지만, 값을 반환하지는 않는다.
&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// empty() 는 스택이 비어있으면 true 아니면 false를 반환한다.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;스택이 비어있습니다&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;section-2&quot;&gt;스택을 활용한 문제들&lt;/h2&gt;
&lt;p&gt;실제로 배운 것을 응용할 때는 관련 알고리즘 문제를 풀어보는 것이 도움이 된다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/9012&quot;&gt;9012번 괄호&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1874&quot;&gt;1874번 스택수열&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 08 Sep 2016 00:00:00 +0900</pubDate>
        <link>http://astrohsy.com/datastructure/stack/</link>
        <guid isPermaLink="true">http://astrohsy.com/datastructure/stack/</guid>
        
        <category>Stack</category>
        
        <category>LIFO</category>
        
        
        <category>DataStructure</category>
        
      </item>
    
  </channel>
</rss>
